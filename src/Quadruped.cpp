#include "Quadruped.h"


Quadruped::Quadruped() : pitchPID(&_measuredPitchAngle, &_outputPitchAngle, &_pitchSetpoint, PITCH_KP, PITCH_KI, PITCH_KD, DIRECT),
                         rollPID(&_measuredRollAngle, &_outputRollAngle, &_rollSetpoint, ROLL_KP, ROLL_KI, ROLL_KD, DIRECT)
{};

/*!
 *    @brief Initializes robot parameters
 *    @param inputX Initial X input
 *    @param inputY Initial Y input
 *    @param inputZ Initial Z input
 *    @param legMotors  Array of Motor structs
*/
void Quadruped::init(int16_t inputX, int16_t inputY, int16_t inputZ, Motor legMotors[], bool willProvideIMUFeedback) {

  _mode = STANDING;
  _userDesiredMode = STANDING;

  for (int8_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
    LegID LEG = _enumFromIndex(leg);
    legStepPlanner[leg].init(LEG, inputX, inputY, inputZ);
    legKinematics[leg].init(LEG, inputX, inputY, inputZ, legMotors);
  }

  for (int8_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
    _footPositions[leg].x = inputX;
    _footPositions[leg].y = inputY;
    _footPositions[leg].z = inputZ;
  }
  _originFootPosition.x = inputX;
  _originFootPosition.y = inputY;
  _originFootPosition.z = inputZ;

  _IMUData.x = 0;
  _IMUData.y = 0;
  _IMUData.z = 0;
  _willProvideIMUFeedback = willProvideIMUFeedback;
  pitchPID.SetMode(AUTOMATIC);
  pitchPID.SetOutputLimits(-PITCH_MAXIMUM_ANGLE, PITCH_MAXIMUM_ANGLE);
  rollPID.SetMode(AUTOMATIC);
  rollPID.SetOutputLimits(-ROLL_MAXIMUM_ANGLE, ROLL_MAXIMUM_ANGLE);
  setBalanceOrientation(0, 0);

};


void Quadruped::setMode(RobotMode mode) {
  _userDesiredMode = mode;
}

/*!
 *    @brief Loads a gait that can be used with walk()
 *    @param gaitParameters An array of gait parameters generated by gaitCreator.py
 *    @param gaitSchedule   Gait step schedule generated by gaitCreator.py
*/
void Quadruped::loadGait(int16_t gaitParameters[], int16_t gaitSchedule[][ROBOT_LEG_COUNT]) {

  _gait.stepDistance = gaitParameters[STRIDE_LENGTH_INDEX];
  _gait.amplitude = gaitParameters[GAIT_AMPLITUDE_INDEX];
  _gait.drawBackReduction = gaitParameters[GAIT_DRAW_BACK_FACTOR_INDEX];
  _gait.stepDuration = gaitParameters[STEP_DURATION_INDEX];
  _gait.stepCount = gaitParameters[STEP_COUNT_INDEX];
  _gait.pauseDuration = gaitParameters[PAUSE_DURATION_INDEX];

  for (int16_t x = 0; x < _gait.stepCount; x++ ) {
    for (int16_t i = 0; i < ROBOT_LEG_COUNT; i++)
      _gaitSchedule[x][i] = gaitSchedule[x][i];
  }
  for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
    legStepPlanner[leg].setGaitParameters(_gait.amplitude, _gait.drawBackReduction);
  }
}

/*!
 *    @brief Sets robot into walk mode and manages gait schedule
 *    @param controlCoordinateX X coordinate of a joystick
 *    @param controlCoordinateY Y coordinate of a joystick
*/
void Quadruped::walk(int16_t controlCoordinateX, int16_t controlCoordinateY, Coordinate outputFootPositions[ROBOT_LEG_COUNT]) {

  if (_mode == STANDING) {
    _mode = WALKING;
    _firstStep = true;
    _previousStepUpdate = millis();
    _justUpdatedWalk = false;
    _currentGaitScheduleIndex = 0;
  }

  if (_mode == WALKING) {
    if (((int16_t)(millis() - _previousStepUpdate) == (_gait.stepDuration + _gait.pauseDuration)) && _justUpdatedWalk == false) {

      int16_t stepDistance = 0;
      int16_t drawBackDistance = 0;

      // Weird stuff here; fix later. 
      if (_firstStep && _currentGaitScheduleIndex != _gait.stepCount - 1) {
        if (_gait.stepCount == 2) {
          stepDistance = _gait.stepDistance / 2;
          drawBackDistance = _gait.stepDistance / 2;
        }
        else if (_gait.stepCount == 4) {
          stepDistance = (2*(_currentGaitScheduleIndex) + 1) * _gait.stepDistance / 6;
          drawBackDistance = _gait.stepDistance / 6;
        }
      }
      else {
        if (_gait.stepCount == 2) {
          drawBackDistance = _gait.stepDistance;
        }
        else if (_gait.stepCount == 4) {
          drawBackDistance = _gait.stepDistance / 3;    // Notice that this causes innaccuracies; step distances that aren't multiples of 3 will have a step error. This has been 
                                                        // fixed by making all step distances in a 
        }
        stepDistance = _gait.stepDistance;
      }

      if (_gaitSchedule[_currentGaitScheduleIndex][0] == SHIFT) {
        
      }

      for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
        switch (_gaitSchedule[_currentGaitScheduleIndex][leg]) {
          case TAKE_STEP:
            legStepPlanner[leg].requestStep(controlCoordinateX, controlCoordinateY, _gait.stepDuration, stepDistance);
            break;
          case DRAW_BACK:
            legStepPlanner[leg].requestDrawBack(controlCoordinateX, controlCoordinateY, _gait.stepDuration, drawBackDistance);
            break;
        }
      }

      _currentGaitScheduleIndex++;
      if (_currentGaitScheduleIndex == _gait.stepCount) {
        _currentGaitScheduleIndex = 0;
        _firstStep = false;
      }
      
      _justUpdatedWalk = true;
      _previousStepUpdate = millis();
    }

    if ((millis() - _previousStepUpdate) % _gait.stepDuration != 0) _justUpdatedWalk = false;

  for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
    outputFootPositions[leg].x = legStepPlanner[leg].dynamicFootPosition.x;
    outputFootPositions[leg].y = legStepPlanner[leg].dynamicFootPosition.y;
    outputFootPositions[leg].z = legStepPlanner[leg].dynamicFootPosition.z;
  }

  }

  for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
    if (legStepPlanner[leg].update()) {
      // _footPositions[leg].x += legStepPlanner[leg].dynamicFootPosition.x;
      // _footPositions[leg].y += legStepPlanner[leg].dynamicFootPosition.y;
      // _footPositions[leg].z += (legStepPlanner[leg].dynamicFootPosition.z) - _originFootPosition.z;
      _footPositions[leg].x = legStepPlanner[leg].dynamicFootPosition.x;
      _footPositions[leg].y = legStepPlanner[leg].dynamicFootPosition.y;
      _footPositions[leg].z = (legStepPlanner[leg].dynamicFootPosition.z);
    }
  }

  // for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
  //   legKinematics[leg].setFootEndpoint(_footPositions[leg].x, _footPositions[leg].y, _footPositions[leg].z);
  // }

};


void Quadruped::giveIMUFeedback(double accelX, double accelY, double accelZ) {
  _IMUData.x = accelX;
  _IMUData.y = accelY;
  _IMUData.z = accelZ;
}


/*!
 *    @brief Calculates the roll and pitch angles (YXZ rotation sequence) of the robot based on data provided to giveIMUFeedback(). 
      Refer to this paper from nxp: https://www.nxp.com/files-static/sensors/doc/app_note/AN3461.pdf 
 *    @param roll A pointer to roll angle variable
 *    @param pitch A pointer to pitch angle variable
*/
void Quadruped::getPitchRoll(double *pitch, double *roll) {
  if (!_willProvideIMUFeedback) return;
  
  double _roll, _pitch;

  _filteredIMUData.x = _IMUData.x * LPF_SMOOTHING_FACTOR + (_filteredIMUData.x * (1.0 - LPF_SMOOTHING_FACTOR));
  _filteredIMUData.y = _IMUData.y * LPF_SMOOTHING_FACTOR + (_filteredIMUData.y * (1.0 - LPF_SMOOTHING_FACTOR));
  _filteredIMUData.z = _IMUData.z * LPF_SMOOTHING_FACTOR + (_filteredIMUData.z * (1.0 - LPF_SMOOTHING_FACTOR));

  _roll = (atan2(-_filteredIMUData.y, _filteredIMUData.z) * 180)/PI;

#ifdef IMU_FLIPPED
  if (_roll < 0) _roll += 180;
  else if (_roll > 0) _roll -= 180;
#endif

  _pitch = (atan2(_filteredIMUData.x, sqrt(pow(_filteredIMUData.y,2) + pow(_filteredIMUData.z, 2)))*180)/PI;

  *roll = _roll;
  *pitch = _pitch;
}


void Quadruped::setBalanceOrientation(int16_t rollSetpoint, int16_t pitchSetpoint) {
  _pitchSetpoint = pitchSetpoint;
  _rollSetpoint = rollSetpoint;
};


void Quadruped::computeStaticMovement(Coordinate translationOffsets, Coordinate rotationAngles, Coordinate outputFootPositions[ROBOT_LEG_COUNT]) {

  int16_t offsetX = translationOffsets.x;
  int16_t offsetY = translationOffsets.y;
  int16_t offsetZ = translationOffsets.z;
  int16_t rollAngle = rotationAngles.x;
  int16_t pitchAngle = rotationAngles.y;
  int16_t yawAngle = rotationAngles.z;

  int16_t offsetXL, offsetYL, rollAngleL, pitchAngleL, yawAngleL;   // Used for intermediate computations;

  // Constraints
  if (abs(offsetX) > (BODY_LENGTH * (PERCENT_LENGTH_TRANSLATION / 100))) {
    offsetXL = (int16_t)((float)BODY_LENGTH * ((float)PERCENT_LENGTH_TRANSLATION / 100));
    if (offsetX < 0)  offsetXL *= -1;
    offsetX = offsetXL;
  } 

  if (abs(offsetY) > (BODY_WIDTH * (PERCENT_WIDTH_TRANSLATION / 100))) {
    offsetYL = (int16_t)((float)BODY_WIDTH * ((float)PERCENT_WIDTH_TRANSLATION / 100));
    if (offsetY < 0)  offsetYL *= -1;
    offsetY = offsetYL;
  } 

  if ((offsetZ + _originFootPosition.z) > MAX_HEIGHT) {
    offsetZ = MAX_HEIGHT - _originFootPosition.z;
  }
  else if ((offsetZ + _originFootPosition.z) < MIN_HEIGHT) {
    offsetZ = MIN_HEIGHT - _originFootPosition.z;
  }

  if (abs(rollAngle) > ROLL_MAXIMUM_ANGLE) {
    rollAngleL = ROLL_MAXIMUM_ANGLE;
    if (rollAngle < 0)  rollAngleL *= -1;
    rollAngle = rollAngleL;
  }

  if (abs(pitchAngle) > PITCH_MAXIMUM_ANGLE) {
    pitchAngleL = PITCH_MAXIMUM_ANGLE;
    if (pitchAngle < 0)  pitchAngleL *= -1;
    pitchAngle = pitchAngleL;
  }

  if (abs(yawAngle) > YAW_MAXIMUM_ANGLE) {
    yawAngleL = YAW_MAXIMUM_ANGLE;
    if (yawAngle < 0)  yawAngleL *= -1;
    yawAngle = yawAngleL;
  }

  rollAngleL = rollAngle; 
  pitchAngleL = pitchAngle;
  yawAngleL = yawAngle;

  for (int8_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {

    outputFootPositions[leg].x = _originFootPosition.x;
    outputFootPositions[leg].y = _originFootPosition.y;
    outputFootPositions[leg].z = _originFootPosition.z + offsetZ;

    int16_t footYOffset, footXOffset, twistXOffset, twistYOffset, twistZOffset, centerToCornerAngle, centerToCornerLength;

    // Apply X-axis offset while assuming a pitch
    outputFootPositions[leg].z += offsetX * sin(pitchAngleL * (PI / 180));
    outputFootPositions[leg].x -= offsetX * cos(pitchAngleL * (PI / 180));

     // Apply Y-axis offset while assuming a roll
    outputFootPositions[leg].z -= offsetY * sin(rollAngleL * (PI / 180));
    footYOffset = offsetY * cos(rollAngleL * (PI / 180));   
    if (leg == 0 || leg == 3) outputFootPositions[leg].y += footYOffset;
    if (leg == 1 || leg == 2) outputFootPositions[leg].y -= footYOffset;

    // (Used for both calculations)
    float shoulderToGround = 0;

    // Pitch
    if (leg == 0 || leg == 1) 
      shoulderToGround = (float)(_originFootPosition.z + offsetZ) - (sin((float)pitchAngleL * ((float)PI / 180)) * ((float)BODY_LENGTH / 2));
    else if (leg == 2 || leg == 3) 
      shoulderToGround = (float)(_originFootPosition.z + offsetZ) + (sin((float)pitchAngleL * ((float)PI / 180)) * ((float)BODY_LENGTH / 2));

    outputFootPositions[leg].z += (cos(pitchAngleL * (PI / 180)) * shoulderToGround) - (_originFootPosition.z + offsetZ);
    outputFootPositions[leg].x += (sin(pitchAngleL * (PI / 180)) * shoulderToGround); 

    twistZOffset = sin(pitchAngleL * (PI / 180)) * ((BODY_LENGTH / 2) - cos(pitchAngleL * (PI / 180)) * (BODY_LENGTH / 2));
    twistXOffset = cos(pitchAngleL * (PI / 180)) * ((BODY_LENGTH / 2) - cos(pitchAngleL * (PI / 180)) * (BODY_LENGTH / 2));

    if (shoulderToGround > (_originFootPosition.z + offsetZ)) {
      outputFootPositions[leg].z += twistZOffset;
      outputFootPositions[leg].x -= twistXOffset;
    }
    else if (shoulderToGround < (_originFootPosition.z + offsetZ)) {
      outputFootPositions[leg].z -= twistZOffset;
      outputFootPositions[leg].x += twistXOffset;
    }

    // Roll
    if (leg == 0 || leg == 3) 
      shoulderToGround = (float)(_originFootPosition.z + offsetZ) - (sin((float)rollAngleL * ((float)PI / 180)) * ((float)BODY_WIDTH / 2));
    else if (leg == 1 || leg == 2) 
      shoulderToGround = (float)(_originFootPosition.z + offsetZ)+ (sin((float)rollAngleL * ((float)PI / 180)) * ((float)BODY_WIDTH / 2));

    outputFootPositions[leg].z += (cos(rollAngleL * (PI / 180)) * shoulderToGround) - (_originFootPosition.z + offsetZ);

    footYOffset = (sin(rollAngleL * (PI / 180)) * shoulderToGround);
    if (leg == 0 || leg == 3) outputFootPositions[leg].y += footYOffset;
    if (leg == 1 || leg == 2) outputFootPositions[leg].y -= footYOffset;

    twistZOffset = sin(rollAngleL * (PI / 180)) * ((BODY_WIDTH / 2) - cos(rollAngleL * (PI / 180)) * (BODY_WIDTH / 2));
    twistYOffset = cos(rollAngleL * (PI / 180)) * ((BODY_WIDTH / 2) - cos(rollAngleL * (PI / 180)) * (BODY_WIDTH / 2));

    if (shoulderToGround > (_originFootPosition.z + offsetZ)) {
      outputFootPositions[leg].z += twistZOffset;
      outputFootPositions[leg].y -= twistYOffset;
    }
    else if (shoulderToGround < (_originFootPosition.z + offsetZ)) {
      outputFootPositions[leg].z -= twistZOffset;
      outputFootPositions[leg].y += twistYOffset;
    }

    // Yaw
    centerToCornerAngle = atan(((float)BODY_WIDTH / 2) / ((float)BODY_LENGTH / 2)) * (180 / PI);
    centerToCornerLength = sqrt(pow((BODY_LENGTH / 2), 2) + pow((BODY_WIDTH / 2), 2));
    footYOffset = centerToCornerLength * cos((90 - centerToCornerAngle - yawAngleL) * (PI / 180)) - (BODY_WIDTH / 2);
    footXOffset = centerToCornerLength * sin((90 - centerToCornerAngle - yawAngleL) * (PI / 180)) - (BODY_LENGTH / 2);
    if (leg == 0 || leg == 2) {
      outputFootPositions[leg].y += footYOffset;
      if (leg == 0) outputFootPositions[leg].x += footXOffset;
      if (leg == 2) outputFootPositions[leg].x -= footXOffset;
    }
    if (leg == 1 || leg == 3) {
      outputFootPositions[leg].y -= footYOffset;
      if (leg == 1) outputFootPositions[leg].x -= footXOffset;
      if (leg == 3) outputFootPositions[leg].x += footXOffset;
    }

  }
}



/*!
 *    @brief Does the full computation for the foot position while considering all user inputs.
 *    @param inputX When in Standing mode, this is a translation in the X direction. When in Walking mode, this represents a X-axis controller input. 
 *    @param inputY When in Standing mode, this is a translation in the Y direction. When in Walking mode, this represents a Y-axis controller input. 
*/
void Quadruped::compute(int16_t inputX, int16_t inputY, int16_t inputZ, int16_t rollAngle, int16_t pitchAngle, int16_t yawAngle) {

  Coordinate translationInputs;
  Coordinate rotationInputs;
  translationInputs.x = inputX;
  translationInputs.y = inputY;
  translationInputs.z = inputZ;
  rotationInputs.x = rollAngle;
  rotationInputs.y = pitchAngle;
  rotationInputs.z = yawAngle;

  Coordinate legPositionOutputs[ROBOT_LEG_COUNT];

  if (_userDesiredMode == STANDING) {

    computeStaticMovement(translationInputs, rotationInputs, legPositionOutputs);

    _mode = STANDING;
  }

  else if (_userDesiredMode == BALANCED_STANDING) {
    getPitchRoll(&_measuredPitchAngle, &_measuredRollAngle);
    pitchPID.Compute();
    rollPID.Compute();

    translationInputs.x = 0;
    translationInputs.y = 0;
    translationInputs.z = 0;
    rotationInputs.x = _outputRollAngle;
    rotationInputs.y = _outputPitchAngle;
    rotationInputs.z = 0;
    
    computeStaticMovement(translationInputs, rotationInputs, legPositionOutputs);
    _mode = BALANCED_STANDING;
  }

  else if (_userDesiredMode == WALKING) {
    walk(inputX, inputY, legPositionOutputs);
    _mode = WALKING;
  }

  for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
    _footPositions[leg] = legPositionOutputs[leg];
    legKinematics[leg].setFootEndpoint(_footPositions[leg].x, _footPositions[leg].y, _footPositions[leg].z);
  }

}


/*!
 *    @brief Returns a LegID enum depending on the index of the leg
 *    @returns LegID enum
*/
LegID Quadruped::_enumFromIndex(int8_t index) {
  if (index == 0) return LEG_1;
  else if (index == 1) return LEG_2;
  else if (index == 2) return LEG_3;
  else if (index == 3) return LEG_4;
  else return LEG_1;
};


bool Quadruped::wantsIMUUpdate() {
  if ((micros()) % ((1000 / PID_UPDATE_FREQUENCY) * 1000) <= 50) {
    return true;
  }
    // return true;
  else
    return false;
}
