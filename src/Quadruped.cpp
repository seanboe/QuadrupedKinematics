#include "Quadruped.h"


Quadruped::Quadruped(void) {};

/*!
 *    @brief Initializes robot parameters
 *    @param inputX Initial X input
 *    @param inputY Initial Y input
 *    @param inputZ Initial Z input
 *    @param legMotors  Array of Motor structs
*/
void Quadruped::init(int16_t inputX, int16_t inputY, int16_t inputZ, Motor legMotors[]) {

  _mode = STANDING;

  for (int8_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
    LegID LEG = _enumFromIndex(leg);
    legStepPlanner[leg].init(LEG, inputX, inputY, inputZ);
    legKinematics[leg].init(LEG, inputX, inputY, inputZ, legMotors);
  }

  // Reset this
  _IMUData.x = 0;
  _IMUData.y = 0;
  _IMUData.z = 0;
  _filteredIMUData.x = 0;
  _filteredIMUData.y = 0;
  _filteredIMUData.z = 0;
  _haveIMUFeedback = false;
};

/*!
 *    @brief Loads a gait that can be used with walk()
 *    @param gaitParameters An array of gait parameters generated by gaitCreator.py
 *    @param gaitSchedule   Gait step schedule generated by gaitCreator.py
*/
void Quadruped::loadGait(int16_t gaitParameters[], int16_t gaitSchedule[][ROBOT_LEG_COUNT]) {

  _gait.stepDistance = gaitParameters[STRIDE_LENGTH_INDEX];
  _gait.amplitude = gaitParameters[GAIT_AMPLITUDE_INDEX];
  _gait.drawBackReduction = gaitParameters[GAIT_DRAW_BACK_FACTOR_INDEX];
  _gait.stepDuration = gaitParameters[STEP_DURATION_INDEX];
  _gait.stepCount = gaitParameters[STEP_COUNT_INDEX];
  _gait.pauseDuration = gaitParameters[PAUSE_DURATION_INDEX];

  for (int16_t x = 0; x < _gait.stepCount; x++ ) {
    for (int16_t i = 0; i < ROBOT_LEG_COUNT; i++)
      _gaitSchedule[x][i] = gaitSchedule[x][i];
  }
  for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
    legStepPlanner[leg].setGaitParameters(_gait.amplitude, _gait.drawBackReduction);
  }
}

/*!
 *    @brief Sets robot into walk mode and manages gait schedule
 *    @param controlCoordinateX X coordinate of a joystick
 *    @param controlCoordinateY Y coordinate of a joystick
*/
void Quadruped::walk(int16_t controlCoordinateX, int16_t controlCoordinateY) {

  if (_mode == STANDING) {
    _mode = WALKING;
    _firstStep = true;
    _previousStepUpdate = millis();
    _justUpdatedWalk = false;
    _currentGaitScheduleIndex = 0;
  }

  if (_mode == WALKING) {
    if (((int16_t)(millis() - _previousStepUpdate) == (_gait.stepDuration + _gait.pauseDuration)) && _justUpdatedWalk == false) {

      int16_t stepDistance = 0;
      int16_t drawBackDistance = 0;

      // Weird stuff here; fix later. 
      if (_firstStep && _currentGaitScheduleIndex != _gait.stepCount - 1) {
        if (_gait.stepCount == 2) {
          stepDistance = _gait.stepDistance / 2;
          drawBackDistance = _gait.stepDistance / 2;
        }
        else if (_gait.stepCount == 4) {
          stepDistance = (2*(_currentGaitScheduleIndex) + 1) * _gait.stepDistance / 6;
          drawBackDistance = _gait.stepDistance / 6;
        }
      }
      else {
        if (_gait.stepCount == 2) {
          drawBackDistance = _gait.stepDistance;
        }
        else if (_gait.stepCount == 4) {
          drawBackDistance = _gait.stepDistance / 3;    // Notice that this causes innaccuracies; step distances that aren't multiples of 3 will have a step error. This has been 
                                                        // fixed by making all step distances in a 
        }
        stepDistance = _gait.stepDistance;
      }

      for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
        switch (_gaitSchedule[_currentGaitScheduleIndex][leg]) {
          case TAKE_STEP:
            legStepPlanner[leg].requestStep(controlCoordinateX, controlCoordinateY, _gait.stepDuration, stepDistance);
            break;
          case DRAW_BACK:
            legStepPlanner[leg].requestDrawBack(controlCoordinateX, controlCoordinateY, _gait.stepDuration, drawBackDistance);
            break;
          case PAUSE: break;
        }
      }

      _currentGaitScheduleIndex++;
      if (_currentGaitScheduleIndex == _gait.stepCount) {
        _currentGaitScheduleIndex = 0;
        _firstStep = false;
      }
      
      _justUpdatedWalk = true;
      _previousStepUpdate = millis();
    }

    if ((millis() - _previousStepUpdate) % _gait.stepDuration != 0) _justUpdatedWalk = false;

  }

  updateLegPositions();

};

/*!
 *    @brief Updates the leg step planner
*/
void Quadruped::updateLegPositions() {
  for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
    if (legStepPlanner[leg].update()) {
      int16_t inputX = legStepPlanner[leg].dynamicFootPosition.x;
      int16_t inputY = legStepPlanner[leg].dynamicFootPosition.y;
      int16_t inputZ = legStepPlanner[leg].dynamicFootPosition.z;

      legKinematics[leg].setFootEndpoint(inputX, inputY, inputZ);

    }
  }
}


void Quadruped::giveIMUFeedback(float accelX, float accelY, float accelZ) {
  _IMUData.x = accelX;
  _IMUData.y = accelY;
  _IMUData.z = accelZ;
  _haveIMUFeedback = true;
}

/*!
 *    @brief Calculates the roll and pitch angles (YXZ rotation sequence) of the robot based on data provided to giveIMUFeedback(). 
      Refer to this paper from nxp: https://www.nxp.com/files-static/sensors/doc/app_note/AN3461.pdf 
 *    @param roll A pointer to roll angle variable
 *    @param pitch A pointer to pitch angle variable
*/
void Quadruped::getRollPitch(float *roll, float *pitch) {
  if (!_haveIMUFeedback) return;
  
  float _roll, _pitch;

  _filteredIMUData.x = _IMUData.x * LPF_SMOOTHING_FACTOR + (_filteredIMUData.x * (1.0 - LPF_SMOOTHING_FACTOR));
  _filteredIMUData.y = _IMUData.y * LPF_SMOOTHING_FACTOR + (_filteredIMUData.y * (1.0 - LPF_SMOOTHING_FACTOR));
  _filteredIMUData.z = _IMUData.z * LPF_SMOOTHING_FACTOR + (_filteredIMUData.z * (1.0 - LPF_SMOOTHING_FACTOR));

  _roll = (atan2(-_filteredIMUData.y, _filteredIMUData.z) * 180)/PI;

#ifdef IMU_FLIPPED
  if (_roll < 0) _roll += 180;
  else if (_roll > 0) _roll -= 180;
#endif

  _pitch = (atan2(_filteredIMUData.x, sqrt(pow(_filteredIMUData.y,2) + pow(_filteredIMUData.z, 2)))*180)/PI;

  *roll = _roll;
  *pitch = _pitch;
}

/*!
 *    @brief Returns a LegID enum depending on the index of the leg
 *    @returns LegID enum
*/
LegID Quadruped::_enumFromIndex(int8_t index) {
  if (index == 0) return LEG_1;
  else if (index == 1) return LEG_2;
  else if (index == 2) return LEG_3;
  else if (index == 3) return LEG_4;
  else return LEG_1;
};

