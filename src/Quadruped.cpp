#include "Quadruped.h"


Quadruped::Quadruped() : pitchPID(&_measuredPitchAngle, &_outputPitchAngle, &_pitchSetpoint, PITCH_STANDING_KP, PITCH_STANDING_KI, PITCH_STANDING_KD, DIRECT),
                         rollPID(&_measuredRollAngle, &_outputRollAngle, &_rollSetpoint, ROLL_STANDING_KP, ROLL_STANDING_KI, ROLL_STANDING_KD, DIRECT)
{};

/*!
 *    @brief Initializes robot parameters
 *    @param inputX Initial X input
 *    @param inputY Initial Y input
 *    @param inputZ Initial Z input
 *    @param legMotors  Array of Motor structs
*/
void Quadruped::init(int16_t inputX, int16_t inputY, int16_t inputZ, Motor legMotors[]) {

  _mode = STANDING;
  _userDesiredMode = STANDING;

  for (int8_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
    LegID LEG = _enumFromIndex(leg);
    legStepPlanner[leg].init(LEG, inputX, inputY, inputZ);
    legKinematics[leg].init(LEG, inputX, inputY, inputZ, legMotors);
  }

  for (int8_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
    _footPositions[leg].x = inputX;
    _footPositions[leg].y = inputY;
    _footPositions[leg].z = inputZ;
  }
  _originFootPosition.x = inputX;
  _originFootPosition.y = inputY;
  _originFootPosition.z = inputZ;

  _accelData.x = 0;
  _accelData.y = 0;
  _accelData.z = 0;
  _gyroData.z  = 0;
  _gyroData.y  = 0;
  _gyroData.z  = 0;

  pitchPID.SetMode(AUTOMATIC);
  pitchPID.SetOutputLimits(-PITCH_MAXIMUM_ANGLE, PITCH_MAXIMUM_ANGLE);
  pitchPID.SetSampleTime(1000 / PID_UPDATE_FREQUENCY);

  rollPID.SetMode(AUTOMATIC);
  rollPID.SetOutputLimits(-ROLL_MAXIMUM_ANGLE, ROLL_MAXIMUM_ANGLE);
  rollPID.SetSampleTime(1000 / PID_UPDATE_FREQUENCY);

  setBalanceOrientation(0, 0);

  ImuFuser.init(PID_UPDATE_FREQUENCY, CF_GYRO_BIAS_PITCH, CF_GYRO_BIAS_ROLL);

};


void Quadruped::setMode(RobotMode mode) {
  _userDesiredMode = mode;
}

/*!
 *    @brief Loads a gait that can be used with walk()
 *    @param gaitParameters An array of gait parameters generated by gaitCreator.py
 *    @param gaitSchedule   Gait step schedule generated by gaitCreator.py
*/
void Quadruped::loadGait(int16_t gaitParameters[], int16_t gaitSchedule[][ROBOT_LEG_COUNT]) {

  _gait.stepDistance = gaitParameters[STRIDE_LENGTH_INDEX];
  _gait.amplitude = gaitParameters[GAIT_AMPLITUDE_INDEX];
  _gait.drawBackReduction = gaitParameters[GAIT_DRAW_BACK_FACTOR_INDEX];
  _gait.stepDuration = gaitParameters[STEP_DURATION_INDEX];
  _gait.stepCount = gaitParameters[STEP_COUNT_INDEX];
  _gait.pauseDuration = gaitParameters[PAUSE_DURATION_INDEX];
  _gait.total_actions = gaitParameters[SCHEDULE_ACTIONS_INDEX];

  for (int16_t x = 0; x < _gait.total_actions; x++ ) {
    for (int16_t i = 0; i < ROBOT_LEG_COUNT; i++)
      _gaitSchedule[x][i] = gaitSchedule[x][i];
  }
  for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
    legStepPlanner[leg].setGaitParameters(_gait.amplitude, _gait.drawBackReduction);
  }
}

/*!
 *    @brief Sets robot into walk mode and manages gait schedule
 *    @param controlCoordinateX X coordinate of a joystick
 *    @param controlCoordinateY Y coordinate of a joystick
*/
void Quadruped::walk(int16_t controlCoordinateX, int16_t controlCoordinateY, Coordinate outputFootPositions[ROBOT_LEG_COUNT]) {

  if ((_mode == STANDING) || (_mode == BALANCED_STANDING)) {
    _mode = WALKING;
    _firstStep = true;
    _previousStepUpdate = millis();
    _justUpdatedWalk = false;
    _shouldShift = false;
    _currentGaitScheduleIndex = 0;
  }

  if (_mode == WALKING || _mode == BALANCED_WALKING) {
    if (((int16_t)(millis() - _previousStepUpdate) == (_gait.stepDuration + _gait.pauseDuration)) && _justUpdatedWalk == false) {

      int16_t stepDistance = 0;
      int16_t drawBackDistance = 0;

      // Weird stuff here; fix later. 
      if (_firstStep && _currentGaitScheduleIndex != _gait.stepCount - 1) {
        if (_gait.stepCount == 2) {
          stepDistance = _gait.stepDistance / 2;
          drawBackDistance = _gait.stepDistance / 2;
        }
        else if (_gait.stepCount == 4) {
          stepDistance = (2*(_currentGaitScheduleIndex) + 1) * _gait.stepDistance / 6;
          drawBackDistance = _gait.stepDistance / 6;
        }
      }
      else {
        if (_gait.stepCount == 2) {
          drawBackDistance = _gait.stepDistance;
        }
        else if (_gait.stepCount == 4) {
          drawBackDistance = _gait.stepDistance / 3;    // Notice that this causes innaccuracies; step distances that aren't multiples of 3 will have a step error. This has been 
                                                        // fixed by making all step distances in a 
        }
        stepDistance = _gait.stepDistance;
      }

      // Switch depending on the CURRENT desired action
      switch (_gaitSchedule[_currentGaitScheduleIndex][UNIQUE_COMMAND_INDEX]) {
        case SHIFT_INDEPENDENT:
          for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
            int16_t offsetX = _gaitSchedule[_currentGaitScheduleIndex][UNIQUE_COMMAND_INDEX + 1];
            int16_t offsetY = _gaitSchedule[_currentGaitScheduleIndex][UNIQUE_COMMAND_INDEX + 2];
            if (leg == 0 || leg == 3) legStepPlanner[leg].applyStepOffset(offsetX, offsetY, _gait.stepDuration);
            if (leg == 1 || leg == 2) legStepPlanner[leg].applyStepOffset(offsetX, -offsetY, _gait.stepDuration);
          }
        break;
        default:                                         // Covers the ordinary drawback/walking commands
          for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
            switch (_gaitSchedule[_currentGaitScheduleIndex][leg]) {
              case TAKE_STEP:
                legStepPlanner[leg].requestStep(controlCoordinateX, controlCoordinateY, _gait.stepDuration, stepDistance);
                break;
              case DRAW_BACK:
                legStepPlanner[leg].requestDrawBack(controlCoordinateX, controlCoordinateY, _gait.stepDuration, drawBackDistance);
                break;
            }
          }
          break;
      }

      // Switch depending on an AUXILLARY desired action
      switch (_gaitSchedule[_currentGaitScheduleIndex + 1][UNIQUE_COMMAND_INDEX]) {
        case SHIFT:
          for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
            int16_t offsetX = _gaitSchedule[_currentGaitScheduleIndex + 1][1];
            int16_t offsetY = _gaitSchedule[_currentGaitScheduleIndex + 1][2];
            if (leg == 0 || leg == 3) legStepPlanner[leg].applyStepOffset(offsetX, offsetY);
            if (leg == 1 || leg == 2) legStepPlanner[leg].applyStepOffset(offsetX, -offsetY);
            if (leg == 3) {
              _currentGaitScheduleIndex++;
            }
          }
        break;
      }

      _currentGaitScheduleIndex++;
      if (_currentGaitScheduleIndex == _gait.total_actions) {
        _currentGaitScheduleIndex = 0;
        _firstStep = false;
      }

      _justUpdatedWalk = true;
      _previousStepUpdate = millis();
    }

    if ((millis() - _previousStepUpdate) % _gait.stepDuration != 0) _justUpdatedWalk = false;

  }

  for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
    legStepPlanner[leg].update();
    outputFootPositions[leg].x = legStepPlanner[leg].dynamicFootPosition.x;
    outputFootPositions[leg].y = legStepPlanner[leg].dynamicFootPosition.y;
    outputFootPositions[leg].z = legStepPlanner[leg].dynamicFootPosition.z;
  }

};

bool Quadruped::wantsIMUUpdate() {
  return ImuFuser.shouldUpdateData();
}

void Quadruped::giveIMUFeedback(ThreeAxis &accelData, ThreeAxis &gyroData) {
  _accelData.x = accelData.x;
  _accelData.y = accelData.y;
  _accelData.z = accelData.z;

  _gyroData.x = gyroData.x;
  _gyroData.y = gyroData.y;
  _gyroData.z = gyroData.z;
}


/*!
 *    @brief Calculates the roll and pitch angles (YXZ rotation sequence) of the robot based on data provided to giveIMUFeedback(). 
      Refer to this paper from nxp: https://www.nxp.com/files-static/sensors/doc/app_note/AN3461.pdf 
 *    @param roll A pointer to roll angle variable
 *    @param pitch A pointer to pitch angle variable
*/
void Quadruped::getPitchRoll(double *pitch, double *roll) {
  FusedAngles outputAngles;
  ImuFuser.getFilteredAngles(_accelData, _gyroData, &outputAngles, UNIT_DEGREES);
  *pitch = (double)outputAngles.pitch;
  *roll = (double)outputAngles.roll;
}


void Quadruped::setBalanceOrientation(int16_t rollSetpoint, int16_t pitchSetpoint) {
  _pitchSetpoint = pitchSetpoint;
  _rollSetpoint = rollSetpoint;
};


void Quadruped::computeStaticMovement(Coordinate translationOffsets, Coordinate rotationAngles, Coordinate outputFootPositions[ROBOT_LEG_COUNT]) {

  int16_t offsetX = translationOffsets.x;
  int16_t offsetY = translationOffsets.y;
  int16_t offsetZ = translationOffsets.z;
  int16_t rollAngle = rotationAngles.x;
  int16_t pitchAngle = rotationAngles.y;
  int16_t yawAngle = rotationAngles.z;

  int16_t offsetXL, offsetYL, rollAngleL, pitchAngleL, yawAngleL;   // Used for intermediate computations;

  // Constraints
  if (abs(offsetX) > (BODY_LENGTH * (PERCENT_LENGTH_TRANSLATION / 100))) {
    offsetXL = (int16_t)((float)BODY_LENGTH * ((float)PERCENT_LENGTH_TRANSLATION / 100));
    if (offsetX < 0)  offsetXL *= -1;
    offsetX = offsetXL;
  } 

  if (abs(offsetY) > (BODY_WIDTH * (PERCENT_WIDTH_TRANSLATION / 100))) {
    offsetYL = (int16_t)((float)BODY_WIDTH * ((float)PERCENT_WIDTH_TRANSLATION / 100));
    if (offsetY < 0)  offsetYL *= -1;
    offsetY = offsetYL;
  } 

  if ((offsetZ + _originFootPosition.z) > MAX_HEIGHT) {
    offsetZ = MAX_HEIGHT - _originFootPosition.z;
  }
  else if ((offsetZ + _originFootPosition.z) < MIN_HEIGHT) {
    offsetZ = MIN_HEIGHT - _originFootPosition.z;
  }

  if (abs(rollAngle) > ROLL_MAXIMUM_ANGLE) {
    rollAngleL = ROLL_MAXIMUM_ANGLE;
    if (rollAngle < 0)  rollAngleL *= -1;
    rollAngle = rollAngleL;
  }

  if (abs(pitchAngle) > PITCH_MAXIMUM_ANGLE) {
    pitchAngleL = PITCH_MAXIMUM_ANGLE;
    if (pitchAngle < 0)  pitchAngleL *= -1;
    pitchAngle = pitchAngleL;
  }

  if (abs(yawAngle) > YAW_MAXIMUM_ANGLE) {
    yawAngleL = YAW_MAXIMUM_ANGLE;
    if (yawAngle < 0)  yawAngleL *= -1;
    yawAngle = yawAngleL;
  }

  rollAngleL = rollAngle; 
  pitchAngleL = pitchAngle;
  yawAngleL = yawAngle;

  for (int8_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {

    outputFootPositions[leg].x = _originFootPosition.x;
    outputFootPositions[leg].y = _originFootPosition.y;
    outputFootPositions[leg].z = _originFootPosition.z + offsetZ;

    int16_t footYOffset, footXOffset, twistXOffset, twistYOffset, twistZOffset, centerToCornerAngle, centerToCornerLength;

    // Apply X-axis offset while assuming a pitch
    outputFootPositions[leg].z += offsetX * sin(pitchAngleL * (PI / 180));
    outputFootPositions[leg].x -= offsetX * cos(pitchAngleL * (PI / 180));

     // Apply Y-axis offset while assuming a roll
    outputFootPositions[leg].z -= offsetY * sin(rollAngleL * (PI / 180));
    footYOffset = offsetY * cos(rollAngleL * (PI / 180));   
    if (leg == 0 || leg == 3) outputFootPositions[leg].y += footYOffset;
    if (leg == 1 || leg == 2) outputFootPositions[leg].y -= footYOffset;

    // (Used for both calculations)
    float shoulderToGround = 0;

    // Pitch
    if (leg == 0 || leg == 1) 
      shoulderToGround = (float)(_originFootPosition.z + offsetZ) - (sin((float)pitchAngleL * ((float)PI / 180)) * ((float)BODY_LENGTH / 2));
    else if (leg == 2 || leg == 3) 
      shoulderToGround = (float)(_originFootPosition.z + offsetZ) + (sin((float)pitchAngleL * ((float)PI / 180)) * ((float)BODY_LENGTH / 2));

    outputFootPositions[leg].z += (cos(pitchAngleL * (PI / 180)) * shoulderToGround) - (_originFootPosition.z + offsetZ);
    outputFootPositions[leg].x += (sin(pitchAngleL * (PI / 180)) * shoulderToGround); 

    twistZOffset = sin(pitchAngleL * (PI / 180)) * ((BODY_LENGTH / 2) - cos(pitchAngleL * (PI / 180)) * (BODY_LENGTH / 2));
    twistXOffset = cos(pitchAngleL * (PI / 180)) * ((BODY_LENGTH / 2) - cos(pitchAngleL * (PI / 180)) * (BODY_LENGTH / 2));

    if (shoulderToGround > (_originFootPosition.z + offsetZ)) {
      outputFootPositions[leg].z += twistZOffset;
      outputFootPositions[leg].x -= twistXOffset;
    }
    else if (shoulderToGround < (_originFootPosition.z + offsetZ)) {
      outputFootPositions[leg].z -= twistZOffset;
      outputFootPositions[leg].x += twistXOffset;
    }

    // Roll
    if (leg == 0 || leg == 3) 
      shoulderToGround = (float)(_originFootPosition.z + offsetZ) - (sin((float)rollAngleL * ((float)PI / 180)) * ((float)BODY_WIDTH / 2));
    else if (leg == 1 || leg == 2) 
      shoulderToGround = (float)(_originFootPosition.z + offsetZ)+ (sin((float)rollAngleL * ((float)PI / 180)) * ((float)BODY_WIDTH / 2));

    outputFootPositions[leg].z += (cos(rollAngleL * (PI / 180)) * shoulderToGround) - (_originFootPosition.z + offsetZ);

    footYOffset = (sin(rollAngleL * (PI / 180)) * shoulderToGround);
    if (leg == 0 || leg == 3) outputFootPositions[leg].y += footYOffset;
    if (leg == 1 || leg == 2) outputFootPositions[leg].y -= footYOffset;

    twistZOffset = sin(rollAngleL * (PI / 180)) * ((BODY_WIDTH / 2) - cos(rollAngleL * (PI / 180)) * (BODY_WIDTH / 2));
    twistYOffset = cos(rollAngleL * (PI / 180)) * ((BODY_WIDTH / 2) - cos(rollAngleL * (PI / 180)) * (BODY_WIDTH / 2));

    if (shoulderToGround > (_originFootPosition.z + offsetZ)) {
      outputFootPositions[leg].z += twistZOffset;
      outputFootPositions[leg].y -= twistYOffset;
    }
    else if (shoulderToGround < (_originFootPosition.z + offsetZ)) {
      outputFootPositions[leg].z -= twistZOffset;
      outputFootPositions[leg].y += twistYOffset;
    }

    // Yaw
    centerToCornerAngle = atan(((float)BODY_WIDTH / 2) / ((float)BODY_LENGTH / 2)) * (180 / PI);
    centerToCornerLength = sqrt(pow((BODY_LENGTH / 2), 2) + pow((BODY_WIDTH / 2), 2));
    footYOffset = centerToCornerLength * cos((90 - centerToCornerAngle - yawAngleL) * (PI / 180)) - (BODY_WIDTH / 2);
    footXOffset = centerToCornerLength * sin((90 - centerToCornerAngle - yawAngleL) * (PI / 180)) - (BODY_LENGTH / 2);
    if (leg == 0 || leg == 2) {
      outputFootPositions[leg].y += footYOffset;
      if (leg == 0) outputFootPositions[leg].x += footXOffset;
      if (leg == 2) outputFootPositions[leg].x -= footXOffset;
    }
    if (leg == 1 || leg == 3) {
      outputFootPositions[leg].y -= footYOffset;
      if (leg == 1) outputFootPositions[leg].x -= footXOffset;
      if (leg == 3) outputFootPositions[leg].x += footXOffset;
    }

  }
}



/*!
 *    @brief Does the full computation for the foot position while considering all user inputs.
 *    @param inputX When in Standing mode, this is a translation in the X direction. When in Walking mode, this represents a X-axis controller input. 
 *    @param inputY When in Standing mode, this is a translation in the Y direction. When in Walking mode, this represents a Y-axis controller input. 
*/
void Quadruped::compute(int16_t inputX, int16_t inputY, int16_t inputZ, int16_t rollAngle, int16_t pitchAngle, int16_t yawAngle) {

  Coordinate translationInputs;
  Coordinate rotationInputs;
  translationInputs.x = inputX;
  translationInputs.y = inputY;
  translationInputs.z = inputZ;
  rotationInputs.x = rollAngle;
  rotationInputs.y = pitchAngle;
  rotationInputs.z = yawAngle;

  Coordinate legPositionOutputs[ROBOT_LEG_COUNT];

  Coordinate staticMovementOutput[ROBOT_LEG_COUNT];

  switch(_userDesiredMode) {
    case STANDING:
      computeStaticMovement(translationInputs, rotationInputs, legPositionOutputs);
      _mode = STANDING;
      break;
    case BALANCED_STANDING:
      getPitchRoll(&_measuredPitchAngle, &_measuredRollAngle);

      pitchPID.Compute();
      rollPID.Compute();

      translationInputs.x = 0;
      translationInputs.y = 0;
      translationInputs.z = 0;
      rotationInputs.x = _outputRollAngle;
      rotationInputs.y = _outputPitchAngle;
      rotationInputs.z = 0;

      computeStaticMovement(translationInputs, rotationInputs, legPositionOutputs);
      _mode = BALANCED_STANDING;

      // for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
      //   legStepPlanner[leg].setNewHeight(legPositionOutputs[leg].z);
      // }

      break;
    case WALKING:
      walk(inputX, inputY, legPositionOutputs);
      _mode = WALKING;
      break;
    case BALANCED_WALKING:
      
      if (pitchPID.GetKp() == PITCH_STANDING_KP)
        pitchPID.SetTunings(PITCH_WALKING_KP, PITCH_WALKING_KI, PITCH_WALKING_KD);
      if (rollPID.GetKp() == ROLL_STANDING_KP)
        rollPID.SetTunings(ROLL_WALKING_KP, ROLL_WALKING_KI, ROLL_WALKING_KD);

      walk(inputX, inputY, legPositionOutputs);

      getPitchRoll(&_measuredPitchAngle, &_measuredRollAngle);

      pitchPID.Compute();
      if (rollPID.Compute()) {
        // Serial.print("Measurement: ");
        // Serial.print(_measuredPitchAngle);
        // Serial.print(" , ");
        // Serial.print("PID: ");
        // Serial.println(_outputPitchAngle);

        Serial.println(_measuredPitchAngle - previousMeasuredPitchAngle);

        pidLoopCount ++;
        pitchError += abs(_measuredPitchAngle);
        rollError += abs(_measuredRollAngle);
        pitchROC += abs((double)((_measuredPitchAngle - previousMeasuredPitchAngle) / (double)(millis() - (double)thispreviousTime)));
        rollROC += abs((double)((_measuredRollAngle - previousMeasuredRollAngle) / (double)(millis() - (double)thispreviousTime)));
        previousMeasuredPitchAngle = _measuredPitchAngle;
        previousMeasuredRollAngle = _measuredRollAngle;
        thispreviousTime = millis();

        if (pidLoopCount == 400) {
          Serial.print("Average pitch ROC / ms: ");
          Serial.print((double)(pitchROC / (double)pidLoopCount), 4);
          Serial.print(" Average roll ROC / ms: ");
          Serial.print((double)(rollROC / (double)pidLoopCount), 4);
          Serial.print(" Pitch error: ");
          Serial.print(pitchError);
          Serial.print(" Roll error: ");
          Serial.println(rollError);
          while(1);
        }
      };

      translationInputs.x = 0;
      translationInputs.y = 0;
      translationInputs.z = 0;
      rotationInputs.x = _outputRollAngle;
      rotationInputs.y = _outputPitchAngle;
      rotationInputs.z = 0;

      computeStaticMovement(translationInputs, rotationInputs, staticMovementOutput);

      for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
        legStepPlanner[leg].setNewHeight(staticMovementOutput[leg].z);
        // legPositionOutputs[leg].x += (staticMovementOutput[leg].x - _originFootPosition.x);
        // legPositionOutputs[leg].y += (staticMovementOutput[leg].y - _originFootPosition.y);
      }

      _mode = BALANCED_WALKING;
      break;
  }

  for (int16_t leg = 0; leg < ROBOT_LEG_COUNT; leg++) {
    _footPositions[leg] = legPositionOutputs[leg];
    legKinematics[leg].setFootEndpoint(_footPositions[leg].x, _footPositions[leg].y, _footPositions[leg].z);
  }

}


/*!
 *    @brief Returns a LegID enum depending on the index of the leg
 *    @returns LegID enum
*/
LegID Quadruped::_enumFromIndex(int8_t index) {
  if (index == 0) return LEG_1;
  else if (index == 1) return LEG_2;
  else if (index == 2) return LEG_3;
  else if (index == 3) return LEG_4;
  else return LEG_1;
};
